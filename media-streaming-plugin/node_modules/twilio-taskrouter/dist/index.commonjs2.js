/*! For license information please see index.commonjs2.js.LICENSE.txt */
/*! twilio-taskrouter.js 0.5.13 */(()=>{var e={873:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Supervisor:()=>Ce,TaskRouterEventHandler:()=>be,Worker:()=>Ae,Workspace:()=>Ne});const i=require("lodash");var s=r.n(i);const o=r(142).Gf,n=r(622),a=["trace","debug","info","warn","error","silent"];class d{constructor(e,t){if(!e)throw o.INVALID_ARGUMENT.clone("Error instantiating Logger. <string>moduleName is a required parameter.");this._log=n.getLogger(e),a.forEach(function(e){this[e]=(...t)=>this._log[e](this._getTimestamp(),...t)}.bind(this)),t&&this.setLevel(t)}setLevel(e){if(-1===a.indexOf(e))throw o.INVALID_ARGUMENT.clone("Error setting Logger level. <string>level must be one of ['trace', 'debug', 'info', 'warn', 'error', 'silent']");this._log.setLevel(e,!1),this._log.setDefaultLevel(e)}getLevel(){return a[this._log.getLevel()]}_getTimestamp(){return`[${(new Date).toISOString()}]`}}class c{constructor(e,t={}){if(!s().isString(e))throw new TypeError("Failed to initialize Configuration. <string>token is a required parameter.");this.logIdentifier=t.logIdentifier||+new Date,this._logLevel=t.logLevel||"error",this._log=new d(`Configuration-${this.logIdentifier}`,this._logLevel),this.token=e;let r="";t.edge&&(r+=`.${t.edge}`),t.region&&(r+=`.${t.region}`),this.EB_SERVER=`https://event-bridge${r}.twilio.com/v1/wschannels`,this.WS_SERVER=`wss://event-bridge${r}.twilio.com/v1/wschannels`}updateToken(e){if(!s().isString(e))throw new TypeError("To update the Twilio token, a new Twilio token must be passed in. <string>newToken is a required parameter.");this.token=e}getLogIdentifier(){return this.logIdentifier}}var h=r(142);const l=require("events");var u=r(813);const p="0.5.13",g=global.window||global,_=g.WebSocket?g.WebSocket:r(352),k=p;class f extends l.EventEmitter{constructor(e,t={}){if(super(),!(e&&e instanceof Ae))throw h.Gf.INVALID_ARGUMENT.clone("<Worker>worker is a required parameter to construct EventBridgeSignaling.");const r=e.getLogger(`EventBridgeSignaling-${e.sid}`);if(!s().isNil(t.closeExistingSessions)&&!s().isBoolean(t.closeExistingSessions))throw new TypeError("Invalid type passed for <boolean>closeExistingSessions");this._heartbeat=null,this.webSocket=null,this._log=r,this._worker=e,this.closeExistingSessions=t.closeExistingSessions||!1,this._config=e._config,this.reconnect=!1,this.tokenTimer=null,this.setUpWebSocket()}updateToken(e){if(!e)throw h.Gf.INVALID_ARGUMENT.clone("To update the Twilio token, a new Twilio token must be passed in. <string>newToken is a required parameter.");this.setTokenExpirationEvent(),this._log.info("Updated token for Worker "+this._worker.sid),this.reconnect=!0,this.webSocket.readyState!==this.webSocket.CLOSING&&this.webSocket.readyState!==this.webSocket.CLOSED||this.createWebSocket()}setTokenExpirationEvent(){clearTimeout(this.tokenTimer),this.tokenTimer=setTimeout((()=>{this.reconnect=!1,this.emit("tokenExpired")}),this.tokenLifetime-5e3)}setUpWebSocket(){this._heartbeat&&(this._heartbeat.onsleep=()=>{}),this._heartbeat=new u.y({interval:60}),this.createWebSocket()}setLifetime(e){this.tokenLifetime=e,this.setTokenExpirationEvent()}createWebSocket(){this.numAttempts=1,this.reconnect=!0;const e=`?${h.Iv.TOKEN}=${this._config.token}&${h.Iv.CLOSE_EXISTING_SESSIONS}=${this.closeExistingSessions}&${h.Iv.CLIENT_VERSION}=${k}`;this.webSocket=new _(this._config.WS_SERVER+e),this.webSocket.onopen=()=>{this.numAttempts=1,this.emit("connected"),this._heartbeat.onsleep=()=>{this._log.info("Heartbeat not received in the past 60 seconds. Proceeding to disconnect websocket."),this.webSocket.close()},this._heartbeat.beat()},this.webSocket.onmessage=e=>{if(this._log.debug("Received event",e.data),this._heartbeat.beat(),0===e.data.trim().length)return;let t;try{t=JSON.parse(e.data)}catch(t){return this._log.error("Received data is not valid JSON: "+e.data),void this.emit("error",h.Gf.INVALID_GATEWAY_MESSAGE)}this._log.debug("Emitting event: %s with %s",t.event_type,JSON.stringify(t.payload)),this.emit(t.event_type,t.payload||null,t.event_type)},this.webSocket.onerror=e=>{this._log.error("WebSocket error occurred: ",e),this.emit("error",h.Gf.GATEWAY_CONNECTION_FAILED)},this.webSocket.onclose=e=>{this.reconnect?this._log.info("WebSocket connection has closed. Trying to reconnect."):this._log.info("WebSocket connection has closed. Not reconnecting due to token expiration.");let t=e.reason;const r=e.code;if(s().isEmpty(t)&&(t=`Websocket closed with errorCode=${r}`),this.emit("disconnected",{message:t}),this._heartbeat.onsleep=()=>{},this.reconnect){const e=this.generateBackOffInterval(this.numAttempts);setTimeout((()=>{this.numAttempts++,this.createWebSocket()}),e)}}}generateBackOffInterval(e){const t=Math.ceil(800),r=Math.floor(1e3*Math.min(30,Math.pow(2,e)-1));return Math.round(Math.floor(Math.random()*(r-t+1))+t)}disconnect(){this._log.info("Disconnecting websocket"),null!==this.webSocket&&(["onmessage","onclose","onopen","onerror"].forEach((e=>{this.webSocket[e]=null})),this._heartbeat.onsleep=()=>{},this.webSocket.close()),this.emit("disconnected",{message:"SDK Disconnect"})}}const w=require("axios"),v=require("https"),m={GET:"GET",POST:"POST"};Object.freeze(m);const S=p;class E{constructor(e){if(!(e instanceof c))throw new TypeError("Failed to initialize Request. <Configuration>config is a required parameter.");const t=new v.Agent({maxVersion:"TLSv1.2",minVersion:"TLSv1.2"});this._config=e,this._postClient=w.create({method:m.POST,timeout:h.jz,headers:{clientVersion:S},httpsAgent:t})}post(e,t,r){if(!e)throw new Error("Failed to make POST request. <string>url is a required parameter.");if(!s().isObject(t))throw new Error("Failed to make POST request. <object>paramsJSON is a required parameter.");if(!r)throw new Error("Failed to make POST request. <string>apiVersion is a required parameter.");const i=this.buildRequest(m.POST,e,t);return this._postClient.post(this._config.EB_SERVER,i,{headers:{apiVersion:r}}).then((e=>Promise.resolve(e.data.payload)))}get(e,t,r){if(!e)throw new Error("Failed to make GET request. <string>url is a required parameter.");if(!t)throw new Error("Failed to make GET request. <string>apiVersion is a required parameter.");if(r=r||{},!s().isObject(r))throw new Error("Failed to make GET request. <object>paramsJSON is a required parameter.");const i=this.buildRequest(m.GET,e,r);return this._postClient.post(this._config.EB_SERVER,i,{headers:{apiVersion:t}}).then((e=>Promise.resolve(e.data.payload)))}buildRequest(e,t,r){return JSON.stringify({url:t,method:e,params:r,token:this._config.token})}}const y=require("path");var T=r.n(y);const b=r(142).Gf,R="reservationList",W="reservationInstance",q="workerInstance",A="workerList",C="taskReservationInstance",O="taskList",F="taskInstance",x="taskTransferList",j="taskTransferInstance",D="taskQueueList",U="workerChannels",P="activitiesList",N="customerParticipantInstance",$="workerParticipantInstance",I="holdWorkerParticipantInstance",L="kickWorkerParticipant";class z{constructor(e,t){if(!e||!t)throw b.INVALID_ARGUMENT.clone("Error instantiating Routes class. <string>workspaceSid and <string>workerSid are required parameters.");this.workspaceSid=e,this.workerSid=t,this.routes={[P]:{path:T().join("Workspaces",this.workspaceSid,"Activities")},[q]:{path:T().join("Workspaces",this.workspaceSid,"Workers",this.workerSid)},[A]:{path:T().join("Workspaces",this.workspaceSid,"Workers")},[W]:{path:T().join("Workspaces",this.workspaceSid,"Workers",this.workerSid,"Reservations","%s")},[R]:{path:T().join("Workspaces",this.workspaceSid,"Workers",this.workerSid,"Reservations")},[O]:{path:T().join("Workspaces",this.workspaceSid,"Tasks")},[F]:{path:T().join("Workspaces",this.workspaceSid,"Tasks","%s")},[x]:{path:T().join("Workspaces",this.workspaceSid,"Workers",this.workerSid,"Transfers")},[j]:{path:T().join("Workspaces",this.workspaceSid,"Workers",this.workerSid,"Transfers","%s")},[C]:{path:T().join("Workspaces",this.workspaceSid,"Tasks","%s","Reservations","%s")},[D]:{path:T().join("Workspaces",this.workspaceSid,"TaskQueues")},[U]:{path:T().join("Workspaces",this.workspaceSid,"Workers",this.workerSid,"WorkerChannels")},[N]:{path:T().join("Workspaces",this.workspaceSid,"Workers",this.workerSid,"CustomerParticipant")},[$]:{path:T().join("Workspaces",this.workspaceSid,"Workers",this.workerSid,"WorkerParticipant")},[I]:{path:T().join("Workspaces",this.workspaceSid,"Workers",this.workerSid,"HoldWorkerParticipant")},[L]:{path:T().join("Workspaces",this.workspaceSid,"Workers",this.workerSid,"KickWorkerParticipant")}}}getRoute(e,...t){if(!this.routes[e])throw b.INVALID_ARGUMENT.clone(`Invalid route fetched <string>route "${e}" does not exist.`);if(t.length){let r=Object.assign({},this.routes[e]);if(t.length!==(r.path.match(/%s/g)||[]).length)throw b.INVALID_ARGUMENT.clone(`Invalid number of positional arguments supplied for route ${e}`);for(let e of t)r.path=r.path.replace(/%s/,e);return r}return this.routes[e]}}var H=r(834);class M{constructor(e,t){if(!s().isObject(e))throw new TypeError("Failed to create a WorkerDescriptor. <Descriptor>descriptor is a required parameter.");if(!s().isObject(t))throw new TypeError("Failed to create a WorkerDescriptor. <Configuration>config is a required parameter.");if(!qe.every((t=>t in e)))throw new TypeError("Failed to create a WorkerDescriptor. The provided <Descriptor>descriptor does not contain all properties of a Worker.");this.accountSid=e.account_sid,this.activityName=e.activity_name,this.activitySid=e.activity_sid,this.attributes=JSON.parse(e.attributes),this.available=e.available,this.dateCreated=(0,H.T)(1e3*e.date_created),this.dateStatusChanged=(0,H.T)(1e3*e.date_status_changed),this.dateUpdated=(0,H.T)(1e3*e.date_updated),this.name=e.friendly_name,this.sid=e.sid,this.workspaceSid=e.workspace_sid}}class B{constructor(e){if(!s().isObject(e))throw new TypeError("Failed to instantiate ActivityDescriptor. <Descriptor>descriptor is required.");if(!Q.every((t=>t in e)))throw new TypeError("Failed to instantiate ActivityDescriptor. <Descriptor>descriptor does not contain all properties of an Activity.");this.accountSid=e.account_sid,this.available=e.available,this.dateCreated=(0,H.T)(1e3*e.date_created),this.dateUpdated=(0,H.T)(1e3*e.date_updated),this.name=e.friendly_name,this.sid=e.sid,this.workspaceSid=e.workspace_sid}}const G=r(834).n;const Q=["account_sid","available","date_created","date_updated","friendly_name","sid","workspace_sid"],V=class{constructor(e,t){if(!s().isObject(e))throw new TypeError("Failed to create an Activity. <Worker>worker is a required parameter.");if(!(t instanceof B))throw new TypeError("Failed to create an Activity. <ActivityDescriptor>descriptor is a required parameter.");Object.assign(this,t),this._worker=e,this._isCurrent=!1}get isCurrent(){return this._isCurrent}setAsCurrent(e={}){if(!G(e,{rejectPendingReservations:e=>s().isBoolean(e)}))throw new TypeError(`Failed to set activity=${this.sid}. The options passed in did not match the required types.`);if(e.rejectPendingReservations&&this.available)throw new Error("Unable to reject pending reservations when updating to an Available activity state.");return this._worker._updateWorkerActivity(this.sid,e).then((()=>this))}};var J=r(442);class K{constructor(e,t,r={}){if(!s().isObject(e))throw new TypeError("Failed to initialize ActivitiesEntity. <Worker>worker is a required parameter.");this._activities=new Map,this._log=e.getLogger(`ActivitiesEntity-${e.sid}`),this._request=t,this._worker=e,this._pageSize=r.pageSize||h.L8,s().inRange(this._pageSize,1,h.L8+1)||(this._log.warn("PageSize range for ActivitiesEntity must be between 1 and %d. Setting pageSize to default size=%d",h.L8,h.L8),this._pageSize=1e3)}get activities(){return this._activities}fetchActivities(){const e=this._getPage();return this._getAllActivities(e)}_getAllActivities(e){return e.then((e=>(e.items.forEach((e=>{this._insertActivity(e)})),e.hasNextPage?this._getAllActivities(e.nextPage()):Promise.resolve())))}_getPage(e){e=e||{};const t=this._worker.getRoutes().getRoute(P).path,r={PageSize:this._pageSize};return e.AfterSid&&(r.AfterSid=e.AfterSid),this._request.get(t,h.x6,r).then((e=>new J.default(e.contents.map((e=>new B(e))),(e=>this._getPage({AfterSid:e})),e.after_sid)))}_insertActivity(e){const t=e.sid;this._log.trace(`_insertActivity(sid=${t}, data=${JSON.stringify(e)}`);try{const r=new V(this._worker,e);this._activities.set(t,r)}catch(e){this._log.error(`Unable to create an Activity for sid=${t}. Skipping insert into Activities map. Error: ${e}`)}}}class Y{constructor(e){if(!s().isObject(e))throw new TypeError("Failed to instantiate WorkerChannelDescriptor. <Descriptor>descriptor is required.");if(!ee.every((t=>t in e)))throw new TypeError("Failed to create a WorkerChannelDescriptor. <Descriptor>descriptor does not contain all properties of a Channel.");this.accountSid=e.account_sid,this.assignedTasks=e.assigned_tasks,this.available=!!e.available,this.availableCapacityPercentage=e.available_capacity_percentage,this.capacity=e.configured_capacity,this.dateCreated=(0,H.T)(1e3*e.date_created),this.dateUpdated=(0,H.T)(1e3*e.date_updated),this.lastReservedTime=(0,H.T)(e.last_reserved_time),this.sid=e.sid,this.taskChannelSid=e.task_channel_sid,this.taskChannelUniqueName=e.task_channel_unique_name,this.workerSid=e.worker_sid,this.workspaceSid=e.workspace_sid}}const X=["capacity","available","assignedTasks","availableCapacityPercentage","dateUpdated","lastReservedTime"];class Z extends l.EventEmitter{constructor(e,t,r){if(super(),!(e instanceof Ae))throw new TypeError("Failed to instantiate Worker. <Worker>worker is a required parameter.");if(!(r instanceof Y))throw new TypeError("Failed to instantiate Channel. <WorkerChannelDescriptor>descriptor is a required parameter.");this._request=t,this._log=e.getLogger(`Channel-${r.sid}`),Object.assign(this,r)}_emitEvent(e,t){if(!s().isString(e))throw new TypeError("Error calling _emitEvent(). <string>eventType is a required parameter.");if(!s().isObject(t))throw new TypeError("Error calling method _emitEvent(). <object>rawEventData is a required parameter.");this._update(t),this.emit(e,this)}_update(e){try{const t=new Y(e);X.forEach((e=>{this[e]=t[e]}))}catch(t){this._log.warn("Failed to update Channel sid=%s. Update aborted. Error: %s.",e.sid,t)}return this}}const ee=["account_sid","assigned_tasks","available","available_capacity_percentage","configured_capacity","date_created","date_updated","last_reserved_time","sid","task_channel_sid","task_channel_unique_name","worker_sid","workspace_sid"],te=Z;class re{constructor(e,t,r={}){if(!(e instanceof Ae))throw new TypeError("Failed to initialize ChannelsEntity. <Worker>worker is a required parameter.");this._channels=new Map,this._log=e.getLogger("ChannelsEntity"),this._request=t,this._pageSize=r.pageSize||h.L8,this._worker=e,s().inRange(this._pageSize,1,h.L8+1)||(this._log.warn("PageSize range for ChannelsEntity must be between 1 and %d. Setting pageSize to default size=%d",h.L8,h.L8),this._pageSize=1e3)}get channels(){return this._channels}fetchChannels(){const e=this._getPage();return this._getAllChannels(e)}_getAllChannels(e){return e.then((e=>(e.items.forEach((e=>{this._insertChannel(e)})),e.hasNextPage?this._getAllChannels(e.nextPage()):Promise.resolve())))}_getPage(e){e=e||{};const t=this._worker.getRoutes().getRoute(U).path,r={PageSize:this._pageSize};return e.AfterSid&&(r.AfterSid=e.AfterSid),this._request.get(t,h.x6,r).then((e=>new J.default(e.contents.map((e=>new Y(e))),(e=>this._getPage({AfterSid:e})),e.after_sid)))}_insertChannel(e){const t=e.sid;this._log.trace(`_insertChannel(sid=${t}, data=${JSON.stringify(e)}`);try{const r=new te(this._worker,this._request,e);this._channels.set(t,r)}catch(e){this._log.error(`Unable to create a Channel for sid=${t}. Skipping insert into Channels map. Error: ${e}`)}}}class ie{constructor(e){if(!s().isObject(e))throw new TypeError("Failed to instantiate TransferDescriptor. <Descriptor>descriptor is required.");if(!ne.every((t=>t in e)))throw new TypeError("Failed to instantiate TransferDescriptor. <Descriptor>descriptor does not contain all properties of a Transfer.");this.dateCreated=(0,H.T)(1e3*e.date_created),this.dateUpdated=(0,H.T)(1e3*e.date_updated),this.mode=e.transfer_mode,this.queueSid=e.initiating_queue_sid,this.reservationSid=e.initiating_reservation_sid,this.to=e.transfer_to,this.transferFailedReason=e.transfer_failed_reason,this.type=e.transfer_type,this.sid=e.sid,this.status=e.transfer_status,this.workerSid=e.initiating_worker_sid,this.workflowSid=e.initiating_workflow_sid}}const se=["dateUpdated","status","transferFailedReason"];class oe extends l.EventEmitter{constructor(e,t){if(super(),!(t instanceof ie))throw new TypeError("Failed to instantiate Transfer. <TransferDescriptor>descriptor is a required parameter.");this._log=e.getLogger(`Transfer-${t.sid}`),Object.assign(this,t)}_update(e){try{const t=new ie(e);se.forEach((e=>{this[e]=t[e]}))}catch(t){throw this._log.error(`Failed to update Transfer sid=${e.sid}. Update aborted.`,t),new Error(`Failed to update Transfer sid=${e.sid}. Update aborted. Error: ${t}.`)}return this}}const ne=["date_created","date_updated","initiating_reservation_sid","initiating_worker_sid","initiating_queue_sid","initiating_workflow_sid","sid","transfer_mode","transfer_to","transfer_type","transfer_status"],ae=oe;const de=class extends ae{constructor(e,t){super(e,t)}};const ce=class extends ae{constructor(e,t,r,i){if(super(e,i),"string"!=typeof r)throw new TypeError("Failed to instantiate OutgoingTransfer. <string>taskSid is a required parameter.");this._worker=e,this._request=t,this.taskSid=r}_emitEvent(e,t){if(this._log.trace(`_emitEvent(${e}, ${JSON.stringify(t)})`),!s().isString(e))throw new TypeError("Error calling _emitEvent(). <string>eventType is a required parameter.");if(!s().isObject(t))throw new TypeError("Error calling method _emitEvent(). <object>payload is a required parameter.");this.emit(e,this)}async cancel(){const e=this._worker.getRoutes().getRoute(j,this.sid).path,t={TaskSid:this.taskSid,TransferStatus:h.Uf.canceled},r=await this._request.post(e,t,h.F3);return this._update(r)}};class he extends l.EventEmitter{constructor(e,t,r){if(super(),!(r instanceof ke))throw new TypeError("Failed to instantiate Transfers. <TaskDescriptor>taskDescriptor is a required parameter.");this._log=e.getLogger(`Transfers-${r.sid}`),this._worker=e,this._request=t,this.incoming=r.incomingTransferDescriptor?new de(e,r.incomingTransferDescriptor):null,this.outgoing=r.outgoingTransferDescriptor?new ce(e,t,r.sid,r.outgoingTransferDescriptor):null}_emitEvent(e,t){if(this._log.trace(`_emitEvent(${e}, ${JSON.stringify(t)})`),!s().isString(e))throw new TypeError("Error calling _emitEvent(). <string>eventType is a required parameter.");if(!s().isObject(t))throw new TypeError("Error calling method _emitEvent(). <object>payload is a required parameter.");const r=h._G[e];this.outgoing?this.outgoing.sid===t.sid?Object.keys(s().pick(h._G,["transfer-attempt-failed","transfer-completed","transfer-failed","transfer-canceled"])).indexOf(e)>-1&&(this._updateOutgoing(t),this.outgoing._emitEvent(r,t)):this._log.warn("The transfer %s specified by Event: transfer.%s does not match the current active outgoing transfer for Worker %s. Skipping event.",t.sid,r,this._worker.sid):this._log.warn("An active outgoing transfer does currently exist in Worker %s transfers map for Event: transfer.%s. Skipping event.",this._worker.sid,r)}_updateOutgoing(e,t=!1){!this.outgoing||t?this.outgoing=new ce(this._worker,this._request,e.task_sid,new ie(e)):this.outgoing._update(e)}_update(e){if(e.incoming)if(this.incoming)this.incoming._update(e.incoming);else{const t=new ie(e.incoming);this.incoming=new de(this._worker,this._request,e.incoming.task_sid,t)}if(e.outgoing)if(this.outgoing)this.outgoing._update(e.outgoing);else{const t=new ie(e.outgoing);this.outgoing=new ce(this._worker,this._request,e.outgoing.task_sid,t)}}}const le=he,ue=["attributes","status","workflowSid","workflowName","queueSid","queueName","priority","reason","routingTarget","timeout","taskChannelSid","taskChannelUniqueName","age","addOns","dateUpdated","transfers"];class pe extends l.EventEmitter{constructor(e,t,r,i){if(super(),!(e instanceof Ae))throw new TypeError("Failed to instantiate Task. <Worker>worker is a required parameter.");if(!i)throw new TypeError("Failed to instantiate Task. <TaskDescriptor>descriptor is a required parameter.");if(!(i instanceof ke))throw new TypeError("descriptor should be of type <TaskDescriptor>");if("string"!=typeof r)throw new TypeError("Failed to instantiate Task. <string>reservationSid is a required parameter.");this._worker=e,this._log=e.getLogger(`Task-${i.sid}`),this._request=t,this.transfers=new le(e,t,i),Object.assign(this,i),this.reservationSid=r}complete(e){if(!s().isString(e))throw new TypeError("Error calling method complete(). <string>reason is a required parameter.");const t=this._worker.getRoutes().getRoute(F,this.sid).path,r={AssignmentStatus:h.Qh,Reason:e};return this._request.post(t,r,h.x6).then((e=>this._update(e)))}async transfer(e,t={}){if(!s().isString(e))throw new TypeError("Error calling method transfer(). <string>to is a required parameter.");const r=this._worker.getRoutes().getRoute(x).path,i={ReservationSid:this.reservationSid,TaskSid:this.sid,To:e};t.attributes&&(i.Attributes=t.attributes),t.mode&&(i.Mode=t.mode),t.priority&&(i.Priority=t.priority);const o=await this._request.post(r,i,h.F3);return this._log.info(`Received response to transfer request to Worker/TaskQueue=${e}`),this._log.debug("Response object",o),this.transfers._updateOutgoing(o,!0),this}wrapUp(e={}){const t=this._worker.getRoutes().getRoute(F,this.sid).path,r={AssignmentStatus:h.Nt};if(e.reason){if(!s().isString(e.reason))throw new Error(`Failed to call wrapUp() on Task sid=${this.sid}. A <string>reason is required.`);r.Reason=e.reason}return this._request.post(t,r,h.x6).then((e=>this._update(e)))}setAttributes(e){if(!s().isObject(e))throw new TypeError("Unable to set attributes on Task. <object>attributes is a required parameter.");const t=this._worker.getRoutes().getRoute(F,this.sid).path,r={Attributes:e};return this._request.post(t,r,h.x6).then((e=>this._update(e)))}updateParticipant(e){const t={hold:e=>s().isBoolean(e),holdUrl:e=>s().isString(e),holdMethod:e=>s().isString(e)};if(!(0,H.n)(e,t))throw new TypeError(`Failed to update Participant tied to Task sid=${this.sid}. The options passed in did not match the required types.`);const r=this._worker.getRoutes().getRoute(N).path,i={TaskSid:this.sid};for(const t in e)i[s().upperFirst(t)]=e[t];return this._request.post(r,i,h.F3).then((e=>this._update(e)))}kick(e){if(!s().isString(e))throw new TypeError("Error calling method kick(). <string>workerSid is a required parameter.");const t=this._worker.getRoutes().getRoute(L).path,r={TaskSid:this.sid,TargetWorkerSid:e};return this._request.post(t,r,h.F3).then((e=>this._update(e)))}hold(e,t,r){const i={holdUrl:e=>s().isString(e),holdMethod:e=>s().isString(e)};if(!s().isString(e))throw new TypeError("Error calling method hold(). <string>targetWorkerSid is a required parameter.");if(!s().isBoolean(t))throw new TypeError("Error calling method hold(). <boolean>onHold is a required parameter that is either true or false.");if(!(0,H.n)(r,i))throw new TypeError(`Failed to update Participant tied to Task sid=${this.sid}. The options passed in did not match the required types.`);const o=this._worker.getRoutes().getRoute(I).path,n={TaskSid:this.sid,TargetWorkerSid:e,Hold:t};for(const e in r)n[s().upperFirst(e)]=r[e];return this._request.post(o,n,h.F3).then((e=>this._update(e)))}_emitEvent(e,t){if(this._log.trace(`_emitEvent(${e}, ${JSON.stringify(t)})`),!s().isString(e))throw new TypeError("Error calling _emitEvent(). <string>eventType is a required parameter.");if(!s().isObject(t))throw new TypeError("Error calling method _emitEvent(). <object>payload is a required parameter.");this.emit(e,this,t)}async _emitEventForOutgoingTransfer(e,t){if(this._log.debug(`_emitEventForOutgoingTransfer(${e}, ${JSON.stringify(t)})`),!s().isString(e))throw new TypeError("Error calling _emitEventForOutgoingTransfer(). <string>eventType is a required parameter.");if(!s().isObject(t))throw new TypeError("Error calling method _emitEventForOutgoingTransfer(). <object>payload is a required parameter.");this.transfers.outgoing||this._log.debug("The transfers.outgoing object is NOT present");let r=0;for(;!this.transfers.outgoing&&r<20;)await new Promise((e=>setTimeout(e,500))),r++,this._log.debug("Transfer event arrived, waiting for API response, because transfer object missing",r);for(r=0;this.transfers.outgoing&&this.transfers.outgoing.sid!==t.sid&&r<20;)await new Promise((e=>setTimeout(e,500))),r++,this._log.debug("Transfer event arrived, waiting for API response to get the correct transfer SID",r);this._log.debug("Transfer sid from API response:",this.transfers&&this.transfers.outgoing?this.transfers.outgoing.sid:"No sid"),this._log.debug("Transfer sid from event:",t.sid),this.transfers.outgoing&&this.transfers.outgoing.sid===t.sid?Object.keys(s().pick(h._G,[h.PQ])).indexOf(e)>-1?(this.transfers._updateOutgoing(t),this.emit(h._G[h.PQ],this.transfers.outgoing)):this.transfers._emitEvent(e,t):this._log.debug(`The transfers.outgoing object is either not present or does not match the transfer sid in the event. ${JSON.stringify(t)}`)}_update(e,t={}){try{const r=new ke(e,this._config);ue.forEach((e=>{"transfers"===e?(t.incoming||t.outgoing)&&this.transfers._update(t):this[e]=r[e]}))}catch(t){throw this._log.error(`Failed to update Task sid=${e.sid}. Update aborted.`,t),new Error(`Failed to update Task sid=${e.sid}. Update aborted. Error: ${t}.`)}return this}}const ge=["addons","age","attributes","date_created","date_updated","priority","queue_name","queue_sid","reason","routing_target","sid","assignment_status","task_channel_unique_name","task_channel_sid","timeout","workflow_name","workflow_sid"],_e=pe;class ke{constructor(e){if(!s().isObject(e))throw new TypeError("Failed to instantiate TaskDescriptor. <Descriptor>descriptor is required.");if(!ge.every((t=>t in e)))throw new TypeError("Failed to instantiate TaskDescriptor. <Descriptor>descriptor does not contain all properties of a Task.");this.addOns=JSON.parse(e.addons),this.age=e.age,this.attributes=JSON.parse(e.attributes),this.dateCreated=(0,H.T)(1e3*e.date_created),this.dateUpdated=(0,H.T)(1e3*e.date_updated),this.priority=e.priority,this.queueName=e.queue_name,this.queueSid=e.queue_sid,this.reason=e.reason,this.routingTarget=e.routing_target,this.sid=e.sid,this.status=e.assignment_status,this.taskChannelUniqueName=e.task_channel_unique_name,this.taskChannelSid=e.task_channel_sid,this.timeout=e.timeout,this.workflowName=e.workflow_name,this.workflowSid=e.workflow_sid,this.incomingTransferDescriptor=null,this.outgoingTransferDescriptor=null}}class fe{constructor(e,t,r=[]){if(!s().isObject(e))throw new TypeError("Failed to instantiate ReservationDescriptor. <Descriptor>descriptor is required.");if(!s().isObject(t))throw new TypeError("Failed to instantiate ReservationDescriptor. <Worker>worker is required.");const i=s().filter(Ee,(e=>-1===r.indexOf(e)));if(!s().every(i,(t=>t in e))){const t=s().difference(i,Object.keys(e)).join(", ");throw new TypeError(`Failed to instantiate ReservationDescriptor. <Descriptor>descriptor does not contain all properties of a Reservation. Missing: ${t}`)}this.accountSid=e.account_sid,this.dateCreated=(0,H.T)(1e3*e.date_created),this.dateUpdated=(0,H.T)(1e3*e.date_updated),this.sid=e.sid,this.status=e.reservation_status,this.timeout=e.reservation_timeout,this.workerSid=e.worker_sid,this.workspaceSid=e.workspace_sid,this.taskDescriptor=null,e.canceled_reason_code&&(this.canceledReasonCode=e.canceled_reason_code);const o=t.getLogger(`ReservationDescriptor-${this.sid}`);if(-1===r.indexOf("task"))try{this.taskDescriptor=new ke(e.task)}catch(e){throw o.error("Failed to create a ReservationDescriptor. The 'task' property is malformed."),e}if(-1===r.indexOf(h.fc.taskTransfer)&&"object"==typeof e.task_transfer)try{this.taskDescriptor.incomingTransferDescriptor=new ie(e.task_transfer),this.transferDescriptor=new ie(e.task_transfer)}catch(e){throw o.error("Failed to create a ReservationDescriptor. The 'task_transfer' property is malformed."),e}if(-1===r.indexOf(h.fc.activeOutgoingTaskTransfer)&&"object"==typeof e.active_outgoing_task_transfer)try{this.taskDescriptor.outgoingTransferDescriptor=new ie(e.active_outgoing_task_transfer)}catch(e){throw o.error("Failed to create a ReservationDescriptor. The 'active_outgoing_task_transfer' property is malformed."),e}}}const we=r(834).n,ve=["dateUpdated","canceledReasonCode","status","timeout","task","task_transfer"],me=["reservation_timeout","task","canceled_reason_code"];class Se extends l.EventEmitter{constructor(e,t,r){if(super(),!(e instanceof Ae))throw new TypeError("Failed to instantiate Reservation. <Worker>worker is a required parameter.");if(!(r instanceof fe))throw new TypeError("Failed to instantiate Reservation. <ReservationDescriptor>descriptor is a required parameter.");this._worker=e,this._log=e.getLogger(`Reservation-${r.sid}`),this._request=t,this.task=this._createTask(r),r.transferDescriptor&&(this.transfer=this._createTransfer(r)),Object.assign(this,r),delete this.taskDescriptor,delete this.transferDescriptor}accept(){const e=this._worker.getRoutes().getRoute(W,this.sid).path,t={ReservationStatus:h.M0};return this._request.post(e,t,h.x6).then((e=>this._update(e,me)))}complete(){const e=this._worker.getRoutes().getRoute(W,this.sid).path,t={ReservationStatus:h.in};return this._request.post(e,t,h.x6).then((e=>this._update(e,me)))}reject(e={}){const t=this._worker.getRoutes().getRoute(W,this.sid).path,r={ReservationStatus:h.j3};if(!we(e,{activitySid:e=>s().isString(e)}))throw new TypeError(`Failed to issue Instruction:reject on Reservation sid=${this.sid}. The options passed in did not match the required types.`);for(const t in e)r[h.iR[t]]=e[t];return this._request.post(t,r,h.x6).then((e=>this._update(e,me)))}wrap(){const e=this._worker.getRoutes().getRoute(W,this.sid).path,t={ReservationStatus:h.hO};return this._request.post(e,t,h.x6).then((e=>this._update(e,me)))}call(e,t,r={}){if(!s().isString(e))throw new TypeError("Error calling method call(). <string>from is a required parameter.");if(!s().isString(t))throw new TypeError("Error calling method call(). <string>url is a required parameter.");const i=this._worker.getRoutes().getRoute(W,this.sid).path,o={Instruction:h.O,CallFrom:e,CallUrl:t};if(!we(r,{accept:e=>s().isBoolean(e),record:e=>s().isString(e),statusCallbackUrl:e=>s().isString(e),timeout:e=>s().isInteger(e),to:e=>s().isString(e)}))throw new TypeError(`Failed to issue Instruction:call on Reservation sid=${this.sid}. The options passed in did not match the required types.`);for(const e in r)o[h.xf[e]]=r[e];return this._request.post(i,o,h.x6).then((e=>this._update(e,me)))}dequeue(e={}){const t=this._worker.getRoutes().getRoute(W,this.sid).path,r={Instruction:h.iz};if(!we(e,{from:e=>s().isString(e),to:e=>s().isString(e),postWorkActivitySid:e=>s().isString(e),record:e=>s().isString(e),timeout:e=>s().isInteger(e),statusCallbackUrl:e=>s().isString(e),statusCallbackEvents:e=>s().isString(e)}))throw new TypeError(`Failed to issue Instruction:dequeue on Reservation sid=${this.sid}. The options passed in did not match the required types.`);for(const t in e)r[h.EA[t]]=e[t];return this._request.post(t,r,h.x6).then((e=>this._update(e,me)))}redirect(e,t,r={}){if(!s().isString(e))throw new TypeError("Error calling method redirect(). <string>callSid is a required parameter.");if(!s().isString(t))throw new TypeError("Error calling method redirect(). <string>url is a required parameter.");const i=this._worker.getRoutes().getRoute(W,this.sid).path,o={accept:e=>s().isBoolean(e)},n={Instruction:h.nB,RedirectCallSid:e,RedirectUrl:t};if(!we(r,o))throw new TypeError(`Failed to issue Instruction:redirect on Reservation sid=${this.sid}. The options passed in did not match the required types.`);for(const e in r)n[h.qG[e]]=r[e];return this._request.post(i,n,h.x6).then((e=>this._update(e,me)))}conference(e={}){if(!we(e,{to:e=>s().isString(e),from:e=>s().isString(e),timeout:e=>s().isInteger(e),statusCallback:e=>s().isString(e),statusCallbackMethod:e=>s().isString(e),statusCallbackEvent:e=>s().isString(e),record:e=>s().isString(e),muted:e=>s().isBoolean(e),beep:e=>s().isBoolean(e)||s().isString(e),startConferenceOnEnter:e=>s().isBoolean(e),endConferenceOnExit:e=>s().isBoolean(e),endConferenceOnCustomerExit:e=>s().isBoolean(e),waitUrl:e=>s().isString(e),waitMethod:e=>s().isString(e),earlyMedia:e=>s().isBoolean(e),maxParticipants:e=>s().isInteger(e),conferenceStatusCallback:e=>s().isString(e),conferenceStatusCallbackMethod:e=>s().isString(e),conferenceStatusCallbackEvent:e=>s().isString(e),conferenceRecord:e=>s().isBoolean(e)||s().isString(e),conferenceTrim:e=>s().isString(e),recordingChannels:e=>s().isString(e),recordingStatusCallback:e=>s().isString(e),recordingStatusCallbackMethod:e=>s().isString(e),conferenceRecordingStatusCallback:e=>s().isString(e),conferenceRecordingStatusCallbackMethod:e=>s().isString(e),region:e=>s().isString(e),sipAuthUsername:e=>s().isString(e),sipAuthPassword:e=>s().isString(e)}))throw new TypeError(`Failed to issue Instruction:conference on Reservation sid=${this.sid}. The options passed in did not match the required types.`);const t=this._worker.getRoutes().getRoute(W,this.sid).path,r={Instruction:h.FB};for(const t in e)r[s().upperFirst(t)]=e[t];return this._request.post(t,r,h.x6).then((()=>this))}updateParticipant(e){if(!we(e,{endConferenceOnExit:e=>s().isBoolean(e),mute:e=>s().isBoolean(e),beepOnExit:e=>s().isBoolean(e)}))throw new TypeError(`Failed to update Worker Participant tied to Reservation sid=${this.sid}. The options passed in did not match the required types.`);const t=this._worker.getRoutes().getRoute($).path,r={ReservationSid:this.sid};for(const t in e)r[s().upperFirst(t)]=e[t];return this._request.post(t,r,h.F3).then((()=>this))}_createTask(e){if(!(e instanceof fe))return this._log.error(`Error calling method _createTask() for Reservation                              sid=${this.sid}. <ReservationDescriptor>reservationDescriptor                              is a required parameter.`),{};const t=e.taskDescriptor;try{return new _e(this._worker,this._request,e.sid,t)}catch(e){return this._log.error(`Failed to create a Task for Reservation sid=${this.sid}. Error: ${e}`),{}}}_createTransfer(e){if(!(e instanceof fe))return this._log.error(`Error calling method _createTransfer() for Reservation                              sid=${this.sid}. <ReservationDescriptor>reservationDescriptor                              is a required parameter.`),{};const t=e.transferDescriptor;try{return new de(this._worker,t)}catch(e){return this._log.error(`Failed to create a Transfer for Reservation sid=${this.sid}. Error: ${e}`),{}}}_update(e,t=[]){try{const r=new fe(e,this._worker,t);ve.forEach((i=>{if("task"===i){if(-1===t.indexOf("task")){const t=e.task_transfer,r=e.active_outgoing_task_transfer;this.task._update(e.task,{incoming:t,outgoing:r})}}else"canceledReasonCode"===i?-1===t.indexOf("canceled_reason_code")&&e.canceled_reason_code&&(this[i]=r[i]):"task_transfer"===i&&e.task_transfer?this.transfer._update(e.task_transfer):this[i]=r[i]}))}catch(t){throw this._log.error(`Failed to update Reservation sid=${e.sid}. Update aborted. Error: ${t}.`),t}return this}_emitEvent(e,t){if(!s().isString(e))throw new TypeError("Error calling _emitEvent(). <string>eventType is a required parameter.");if(!s().isObject(t))throw new TypeError("Error calling method _emitEvent(). <object>rawEventData is a required parameter.");this._update(t),this.emit(e,this)}}const Ee=["account_sid","date_created","date_updated","reservation_status","sid","task","reservation_timeout","worker_sid","workspace_sid"],ye=Se;class Te extends l.EventEmitter{constructor(e,t,r={}){if(super(),!(e instanceof Ae))throw new TypeError("Failed to initialize ReservationsEntity. <Worker>worker is a required parameter.");this._worker=e,this._log=e.getLogger("ReservationsEntity"),this._request=t,this._reservations=new Map,this._reservationSidsByTask=new Map,this._pageSize=r.pageSize||h.L8,s().inRange(this._pageSize,1,h.L8+1)||(this._log.warn("PageSize range for ReservationsEntity must be between 1 and %d. Setting pageSize to default size=%d",h.L8,h.L8),this._pageSize=1e3)}get reservations(){return new Map(Array.from(this._reservations).filter((e=>!e[1][1])).map((e=>[e[0],e[1][0]])))}fetchReservations(){const e=this._getPage();return this._reservations.clear(),this._getAllReservations(e)}_getAllReservations(e){return e.then((e=>{e.items.forEach((e=>{this._insertReservation(e)})),e.hasNextPage&&this._getAllReservations(e.nextPage())}))}_getPage(e){e=e||{};const t=this._worker.getRoutes().getRoute(R).path,r={Active:"true",PageSize:this._pageSize};return e.AfterSid&&(r.AfterSid=e.AfterSid),this._request.get(t,h.F3,r).then((e=>new J.default(e.contents.map((e=>new fe(e,this._worker))),(e=>this._getPage({AfterSid:e})),e.after_sid)))}_insertReservation(e){const t=e.sid;this._log.trace("_insertReservation(sid=%s, data=%s)",t,JSON.stringify(e)),this._reservations.has(t)&&this._log.debug("Reservation %s already exists for Worker %s. Attempting to overwrite it.",t,this._worker.sid);try{const r=new ye(this._worker,this._request,e);return this._reservations.set(t,[r,!1]),this._reservationSidsByTask.has(r.task.sid)?this._reservationSidsByTask.get(r.task.sid).add(r.sid):this._reservationSidsByTask.set(r.task.sid,new Set([r.sid])),this._log.debug("Successfully created and inserted %s for %s to Task-Reservation lookup. Contents: %s",r.sid,r.task.sid,this._reservationSidsByTask.get(r.task.sid)),r}catch(e){throw this._log.error("Unable to create a Reservation for sid=%s. Skipping insert into Reservations map. Error: %s",t,e),e}}insert(e){this._log.trace("_insertReservation(sid=%s, data=%s)",e.sid,JSON.stringify(e));const t=new fe(e,this._worker);return this._insertReservation(t)}getTasks(e){if(!this._reservationSidsByTask.has(e))return null;const t=this._reservationSidsByTask.get(e),r=[];return t.forEach((e=>{const t=this._reservations.get(e);t&&t[0].task&&r.push(t[0].task)})),r}_deleteByReservationSid(e){this._log.trace("_deleteByReservationSid(sid=%s)",e);const t=this.reservations.get(e);t?(this._log.info("Found Reservation sid=%s for Worker %s. Removing reservation and task.",e,this._worker.sid),this._cleanUpReservationAndTask(t)):this._log.info("Reservation with sid=%s not found. Unable to remove Reservation.",e)}_cleanUpReservationAndTask(e){this._log.debug("Soft deleting Reservation sid=%s for Worker %s",e.sid,this._worker.sid),this._reservations.set(e.sid,[e,!0]),setTimeout((()=>{this._log.debug("Hard deleting of Reservation sid=%s for Worker %s",e.sid,this._worker.sid),this._reservations.delete(e.sid)||this._log.warn("Failed to hard delete Reservation sid=%s for Worker %s",e.sid,this._worker.sid)}),5e3)}}class be{constructor(e,t={}){this._worker=e,this._logLevel=t.logLevel||"error",this._log=new d("WorkerEventHandler",this._logLevel)}getTREventsToHandlerMapping(){return{"worker.activity.update":"_workerActivityUpdateHandler","worker.attributes.update":"_workerAttributesUpdateHandler","worker.capacity.update":"_workerCapacityUpdateHandler","worker.channel.availability.update":"_workerChannelAvailabilityUpdateHandler","reservation.created":"_reservationCreatedHandler","reservation.failed":"_reservationFailedHandler","reservation.accepted":"_reservationUpdateHandler","reservation.wrapup":"_reservationUpdateHandler","reservation.completed":"_reservationCleanupEventsHandler","reservation.rejected":"_reservationCleanupEventsHandler","reservation.timeout":"_reservationCleanupEventsHandler","reservation.canceled":"_reservationCleanupEventsHandler","reservation.rescinded":"_reservationCleanupEventsHandler","task.updated":"_taskTypeEventHandler","task.canceled":"_taskTypeEventHandler","task.completed":"_taskTypeEventHandler","task.wrapup":"_taskTypeEventHandler","task.transfer-attempt-failed":"_transferTaskEventHandler","task.transfer-completed":"_transferTaskEventHandler","task.transfer-failed":"_transferTaskEventHandler","task.transfer-initiated":"_transferTaskEventHandler","task.transfer-canceled":"_transferTaskEventHandler"}}_workerActivityUpdateHandler(e){if(this._log.info("Worker %s received Event: worker.activity.update. Proceeding to update ...",this._worker.sid),!e.activity_sid)throw this._log.error("Event: worker.activity.update did not contain an activity_sid. Unable to update Worker %s.",this._worker.sid),new Error(`Failed to update Worker ${this._worker.sid} activity.`);{const t=this._worker.activities.get(e.activity_sid);if(!t)throw this._log.error("The Activity sid=%s specified in Event: worker.activity.update does not exist in the Worker's map of Activities. Unable to update Worker %s activity.",e.activity_sid,this._worker.sid),new Error(`Failed to update Worker ${this._worker.sid} activity.`);this._worker.activity._isCurrent=!1,this._worker.activity=t,t._isCurrent=!0,this._worker.emit("activityUpdated",this._worker._update(e))}}_workerAttributesUpdateHandler(e){this._log.info(`Worker ${this._worker.sid} received Event: worker.attributes.update. Proceeding to update ...`),this._worker.emit("attributesUpdated",this._worker._update(e))}_workerCapacityUpdateHandler(e){if(this._log.info(`Worker ${this._worker.sid} received Event: worker.capacity.update.`),!e.sid)throw this._log.error("Event: worker.capacity.update did not contain a Channel sid. Unable to update Channel for Worker %s.",this._worker.sid),new Error(`Failed to update Worker ${this._worker.sid} channel.`);{const t=this._worker.channels.get(e.sid);if(!t)throw this._log.error("The Channel sid=%s specified in Event: worker.capacity.update does not  exist in the Worker's map of Channels. Unable to update Worker %s channel.",e.sid,this._worker.sid),new Error(`Failed to update Worker ${this._worker.sid} channel.`);t._emitEvent("capacityUpdated",e)}}_workerChannelAvailabilityUpdateHandler(e){if(this._log.info("Worker %s received Event: worker.channel.availability.update.",this._worker.sid),!e.sid)throw this._log.error("Event: worker.capacity.update did not contain a Channel sid. Unable to update Channel for Worker %s.",this._worker.sid),new Error(`Failed to update Worker ${this._worker.sid} channel.`);{const t=this._worker.channels.get(e.sid);if(!t)throw this._log.error("The Channel sid=%s specified in Event: worker.channel.availability.update does not  exist in the Worker's map of Channels. Unable to update Worker %s channel.",e.sid,this._worker.sid),new Error(`Failed to update Worker ${this._worker.sid} channel.`);t._emitEvent("availabilityUpdated",e)}}_reservationCreatedHandler(e){if(this._log.info("Worker %s received Event: reservation.created.",this._worker.sid),!e.sid)throw this._log.error("Event: reservationCreated did not contain a Reservation sid. Unable to create a Reservation for Worker %s.",this._worker.sid),new Error(`Failed to create Reservation for Worker ${this._worker.sid}.`);try{this._log.info("Attempting to create and insert Reservation into Worker %s reservations map.",this._worker.sid);const t=this._worker._dataServices.reservationsEntity.insert(e);this._worker.emit("reservationCreated",t)}catch(e){throw this._log.info("Failed to create and insert Reservation into Worker %s reservations map.",this._worker.sid),new Error(`Failed to create a Reservation for Worker ${this._worker.sid} on Event: reservationCreated. Error: ${e}`)}}_reservationFailedHandler(e){this._log.info("Worker %s received Event: reservation.failed.",this._worker.sid),this._worker.emit("reservationFailed",e)}_reservationUpdateHandler(e,t){const r=h.zb[t];if(this._log.info("Worker %s received Event: %s mapped to %s.",this._worker.sid,t,r),!e.sid)throw this._log.error(`Event: reservation.${r} did not contain a Reservation sid. Unable to update Reservation for Worker ${this._worker.sid}`),new Error(`Failed to update Reservation for Worker ${this._worker.sid}.`);{const t=this._worker.reservations.get(e.sid);if(!t)throw this._log.error(`The Resevation sid=${e.sid} specified in Event: reservation.${r} does not                                         exist in the Worker's map of Reservations. Unable to update Worker ${this._worker.sid} reservation.`),new Error(`Failed to update Worker ${this._worker.sid} reservation.`);t._emitEvent(r,e)}}_reservationCleanupEventsHandler(e,t){const r=h.zb[t];if(this._log.info("Worker %s received Event: %s mapped to %s.",this._worker.sid,t,r),!e.sid)throw this._log.error("Event: reservation.%s did not contain a Reservation sid. Unable to update Reservation for Worker %s.",r,this._worker.sid),new Error(`Failed to update Reservation for Worker ${this._worker.sid}.`);{const t=this._worker.reservations.get(e.sid);t?(this._worker._dataServices.reservationsEntity._deleteByReservationSid(e.sid),t._emitEvent(r,e)):this._log.warn("The reservation specified by Event: reservation.%s does not exist in Worker %s Reservations map. Skipping event.",r,this._worker.sid)}}_taskTypeEventHandler(e,t){const r=h.L3[t];if(this._log.info("Worker %s received Event: %s mapped to %s.",this._worker.sid,t,r),!e.sid)throw this._log.error("Event: task.%s did not contain a Task sid. Unable to emit event for Worker %s.",r,this._worker.sid),new Error(`Failed to emit event for Worker ${this._worker.sid}.`);{const t=this._worker._dataServices.reservationsEntity.getTasks(e.sid);t&&t.length>0?t.forEach((t=>{t._update(e),t._emitEvent(r,e)})):this._log.warn("The task specified by Event: task.%s does not exist in Worker %s Reservations map. Skipping event.",r,this._worker.sid)}}_transferTaskEventHandler(e,t){const r=h.l4[t];if(this._log.info("Worker %s received Event: % mapped to %s.",this._worker.sid,t,r),!e.initiating_reservation_sid||!e.task_sid)throw this._log.error("Event: task.%s did not contain a Reservation sid or Task sid. Unable to emit event for Worker %s.",r,this._worker.sid),new Error(`Failed to emit event for Worker ${this._worker.sid}.`);{const t=this._worker.reservations.get(e.initiating_reservation_sid);t?t.task.sid===e.task_sid?t.task._emitEventForOutgoingTransfer(r,e):this._log.warn("The task %s related to Event: task.%s does not match the expected owning Reservation %s for Worker %s. Skipping event.",e.task_sid,r,t.sid,this._worker.sid):this._log.warn("The reservation %s related to Event: task.%s does not exist in Worker %s Reservations map. Skipping event.",e.initiating_reservation_sid,r,this._worker.sid)}}}const Re=["dateUpdated","dateStatusChanged","attributes","name","available"];class We extends l.EventEmitter{constructor(e,t={},r={Request:E,EventBridgeSignaling:f}){if(super(),!s().isString(e))throw new TypeError("Failed to instantiate Worker. <string>token is a required parameter.");const i={connectActivitySid:e=>s().isString(e),closeExistingSessions:e=>s().isBoolean(e),logLevel:e=>s().isString(e),ebServer:e=>s().isString(e),wsServer:e=>s().isString(e),region:e=>s().isString(e)};let o;(0,H.n)(t,i),this._connectActivitySid=t.connectActivitySid,this._closeExistingSessions=t.closeExistingSessions,this._logLevel=t.logLevel||"error",this._config=new c(e,t),this._log=new d(`Worker-${this._config.getLogIdentifier()}`,this._logLevel),this._request=new r.Request(this._config),this._dataServices={activitiesEntity:new K(this,this._request),channelsEntity:new re(this,this._request),reservationsEntity:new Te(this,this._request)},this._signaling=new r.EventBridgeSignaling(this,{closeExistingSessions:t.closeExistingSessions}),this._subscribeToSignalingEvents(),o=t.eventHandlerClass?new t.eventHandlerClass(this):new be(this),this.taskRouterEventHandler=o}createTask(e,t,r,i,o={}){if(!s().isString(e))throw new TypeError("Error calling method createTask(). <string>to is a required parameter.");if(!s().isString(t))throw new TypeError("Error calling method createTask(). <string>from is a required parameter.");if(!s().isString(r))throw new TypeError("Error calling method createTask(). <string>workflowSid is a required parameter.");if(!s().isString(i))throw new TypeError("Error calling method createTask(). <string>taskQueueSid is a required parameter.");const n={attributes:e=>s().isObject(e),taskChannelUniqueName:e=>s().isString(e),taskChannelSid:e=>s().isString(e)};if(!(0,H.n)(o,n))throw new TypeError(`Failed to create a Task for Worker ${this.sid}. The options passed in did not match the required types.`);const a=this.getRoutes().getRoute(O).path,d={WorkflowSid:r,TaskQueueSid:i,RoutingTarget:this.sid};for(const e in o)"attributes"===e||(d[h.VH[e]]=o[e]);const c={outbound_to:e,from:t};return d.Attributes=Object.assign({},o.attributes,c),this._request.post(a,d,h.x6).then((e=>e.sid))}getLogger(e){return new d(`${e}-${this.sid}`,this._config._logLevel)}setAttributes(e){if(!s().isObject(e))throw new TypeError("Unable to set attributes on Worker. <object>attributes is a required parameter.");const t=this.getRoutes().getRoute(q).path,r={Attributes:e};return this._request.post(t,r,h.x6).then((e=>this._update(e)))}updateToken(e){if(!s().isString(e))throw new TypeError("To update the Twilio token, a new Twilio token must be passed in. <string>newToken is a required parameter.");this._log.info("Proceeding to update the Worker's current active token with a new token."),this._log.debug("New token: "+e);try{this._config.updateToken(e),this._signaling.updateToken(e),this.emit("tokenUpdated")}catch(e){this.emit("error",e)}}_subscribeToSignalingEvents(){this._log.info("Subscribing to Signaling events .... "),this._signaling.on("connected",(()=>{this._log.info("Received Event: 'connected' from Signaling layer. Pending initialization.",this.sid)})),this._signaling.on("disconnected",(e=>{this._log.info("Received Event: 'disconnected' from Signaling layer for Worker %s. %s",this.sid,e),this._unSubscribeFromTaskRouterEvents(),this.emit("disconnected",e)})),this._signaling.on("init",(e=>{this._log.info("Received Event: 'init' from Signaling layer. Proceeding to initialize Worker %s.",e.channel_id),this.sid=e.channel_id,this.accountSid=e.account_sid,this.workspaceSid=e.workspace_sid,this._signaling.setLifetime(e.token_lifetime),this._initialize()})),this._signaling.on("error",(e=>{this._log.info("Received Event: 'error' from Signaling layer for Worker %s.",this.sid),this.emit("error",e)})),this._signaling.on("tokenExpired",(()=>{this._log.info("Received Event: 'tokenExpired' for for Worker %s. Please update the token. Websocket will not reconnect automatically until token is updated.",this.sid),this.emit("tokenExpired")}))}_subscribeToTaskRouterEvents(){this._log.info("Subscribing to TaskRouter events ... ");for(let[e,t]of Object.entries(this.taskRouterEventHandler.getTREventsToHandlerMapping()))this._signaling.on(e,this.taskRouterEventHandler[t])}_unSubscribeFromTaskRouterEvents(){this._log.info("Unsubscribing from TaskRouter events ... ");for(let[e,t]of Object.entries(this.taskRouterEventHandler.getTREventsToHandlerMapping()))this._signaling.removeListener(e,this.taskRouterEventHandler[t])}_initialize(){this._routes=new z(this.workspaceSid,this.sid),this._log.info("Initializing Worker %s...",this.sid);const e=this.getRoutes().getRoute(q).path;let t;this._request.get(e,h.x6).then((e=>{const r=new M(e,this._config);return t=r.activitySid,delete r.activityName,delete r.activitySid,delete r.available,Object.assign(this,r),Promise.all([this._dataServices.activitiesEntity.fetchActivities(),this._dataServices.channelsEntity.fetchChannels(),this._dataServices.reservationsEntity.fetchReservations()])})).then((()=>{this._log.info("Worker %s activities, channels and pending reservations initialized",this.sid),this._setCurrentActivity(t),this._connectActivitySid?this._setWorkerConnectActivity().then((()=>{this._log.info("Successfully updated Worker on connect to Activity=%s",this._connectActivitySid),this._log.info("Worker %s successfully initialized",this.sid)})):this._log.info("Worker %s successfully initialized",this.sid),this._subscribeToTaskRouterEvents(),this.emit("ready",this)})).catch((e=>{this._log.error("Failed to initialize Worker %s. Error: %s",this.sid,e),this.emit("error",`Failed to initialize Worker ${this.sid}`)}))}get channels(){return this._dataServices.channelsEntity.channels}get activities(){return this._dataServices.activitiesEntity.activities}get reservations(){return this._dataServices.reservationsEntity.reservations}_setCurrentActivity(e){const t=this.activities.get(e);if(!t)throw new Error(`Unable to set the current Activity sid=${e} on the Worker.`);t._isCurrent=!0,this.activity=t,this.activity._isCurrent=!0}_setWorkerConnectActivity(){if(!s().isString(this._connectActivitySid))throw new TypeError("Failed to set the Worker's activity to the provided optional connectActivitySid. <string>connectActivitySid must be a string.");return this._updateWorkerActivity(this._connectActivitySid).then((()=>(this._log.info("Successfully set the Worker's activity to the provided connectActivitySid=%s on connection.",this._connectActivitySid),this._connectRetry=0,this))).catch((e=>{if(this._connectRetry>=3)throw this._log.error("Unable to set Worker %s activity to the provided %s on successful connection. %s",this.sid,this._connectActivitySid,e),e;return this._connectRetry=this._connectRetry>0?this._connectRetry+1:1,new Promise((e=>setTimeout(e,500))).then(this._setWorkerConnectActivity.bind(this))}))}_updateWorkerActivity(e,t={}){if(!s().isString(e))throw new TypeError("Error updating Worker Activity: <string>activitySid is a required parameter");const r=this.getRoutes().getRoute(q).path,i={ActivitySid:e};for(const e in t)i[h.UA[e]]=t[e];return this._request.post(r,i,h.x6).then((t=>{try{this._update(t),this.activity._isCurrent=!1;const e=this.activities.get(t.activity_sid);this.activity=e,this.activity._isCurrent=!0}catch(t){throw this._log.error("Failed to update the Worker's activity to sid=%s. Error: %s",e,t),t}return this}))}_update(e){this._log.trace("Attempting to update Worker %s with latest Worker data=%s",this.sid,JSON.stringify(e));try{const t=new M(e,this._config);Re.forEach((e=>{this[e]=t[e]}))}catch(t){this._log.error("Failed to update Worker sid=%s. Update aborted. Error: %s.",e.sid,t)}return this}disconnect(){this._signaling.disconnect()}getRoutes(){return this._routes}}const qe=["account_sid","activity_name","activity_sid","attributes","available","date_created","date_status_changed","date_updated","friendly_name","sid","workspace_sid"],Ae=We;const Ce=class extends Ae{monitor(e,t,r){if(!s().isString(e))throw new TypeError("Error monitoring reservation: <string>taskSid is a required parameter");if(!s().isString(t))throw new TypeError("Error monitoring reservation: <string>reservationSid is a required parameter");if(r&&!s().isObject(r))throw new TypeError("Error monitoring reservation: <string>extraParams must be an object");return this._supervise("monitor",e,t,r)}_supervise(e,t,r,i){const s=this.getRoutes().getRoute(C,t,r).path,o=Object.assign({},i,{Instruction:"supervise",Supervisor:this.sid,SupervisorMode:e});return this._request.post(s,o,h.x6).then((()=>{}))}};class Oe{constructor(e,t={}){if(new.target===Oe)throw new TypeError("You cannot instantiate TaskRouterBase directly");this._config=new c(e,t),this._request=new E(this._config),this.jwt=e,this.accountSid=e.sub,this.workspaceSid=e.grants.task_router.workspace_sid,this.workerSid=e.grants.task_router.worker_sid,this.role=e.grants.task_router.role}}const Fe=["friendly_name","reservation_activity_name","assignment_activity_name","target_workers","max_reserved_workers","task_order","reservation_activity_sid","assignment_activity_sid","workspace_sid","account_sid","sid","date_created","date_updated","lifo_queue"],xe=class{constructor(e){if(!(e instanceof je))throw new TypeError("Failed to create a TaskQueue. <TaskQueueDescriptor>descriptor is a required parameter.");Object.assign(this,e)}};class je{constructor(e){if(!s().isObject(e))throw new TypeError("Failed to instantiate TaskQueueDescriptor. <Descriptor>descriptor is required.");if(!Fe.every((t=>t in e)))throw new TypeError("Failed to instantiate TaskQueueDescriptor. <Descriptor>descriptor does not contain all properties of a TaskQueue.");this.sid=e.sid,this.accountSid=e.account_sid,this.workspaceSid=e.workspace_sid,this.name=e.friendly_name,this.assignmentActivityName=e.assignment_activity_name,this.reservationActivityName=e.reservation_activity_name,this.assignmentActivitySid=e.assignment_activity_sid,this.reservationActivitySid=e.reservation_activity_sid,this.targetWorkers=e.target_workers,this.maxReservedWorkers=e.max_reserved_workers,this.taskOrder=e.task_order,this.dateCreated=(0,H.T)(1e3*e.date_created),this.dateUpdated=(0,H.T)(1e3*e.date_updated)}}const De=class{constructor(e){if(!(e instanceof M))throw new TypeError("Failed to create a WorkerContainer. <WorkerDescriptor>descriptor is a required parameter.");Object.assign(this,e)}},Ue=r(442);class Pe{constructor(e,t,r={}){if(!(e instanceof Ae))throw new TypeError("Failed to initialize WorkspacesEntity. <Worker>worker is a required parameter.");this._Workers=new Map,this._TaskQueues=new Map,this._worker=e,this._request=t,this._log=e.getLogger(`WorkspaceEntity-${this._worker.workspaceSid}`),this._pageSize=r.pageSize||h.L8,s().inRange(this._pageSize,1,h.L8+1)||(this._log.warn("PageSize range for WorkspaceEntity must be between 1 and %d. Setting pageSize to default size=%d",h.L8,h.L8),this._pageSize=h.L8)}get Workers(){return this._Workers}get TaskQueues(){return this._TaskQueues}fetchWorkers(){return this._getAllWorkers(this._getWorkerPage())}fetchTaskQueues(){return this._getAllTaskQueues(this._getTaskQueuePage())}_getAllWorkers(e){return e.then((e=>{e.items.forEach((e=>this._insertWorker(e))),e.hasNextPage&&this._getAllWorkers(e.nextPage())}))}_getWorkerPage(e){e=e||{};const t=this._worker.getRoutes().getRoute(A).path,r={PageSize:this._pageSize};return e.AfterSid&&(r.AfterSid=e.AfterSid),this._request.get(t,h.x6,r).then((e=>new Ue(e.contents.map((e=>new M(e))),(e=>this._getPage({AfterSid:e})),e.after_sid)))}_insertWorker(e){const t=e.sid;this._log.trace("_insertWorker(sid=%s, data=%s)",t,JSON.stringify(e));try{this._Workers.set(t,new De(e))}catch(e){this._log.error("Unable to create a Worker for sid=%s. Skipping insert into Worker map. Error: %s",t,e)}}_getAllTaskQueues(e){return e.then((e=>{e.items.forEach((e=>this._insertTaskQueue(e))),e.hasNextPage&&this._getAllTaskQueues(e.nextPage())}))}_getTaskQueuePage(e){e=e||{};const t=this._worker.getRoute(D).path,r={PageSize:this._pageSize};return e.AfterSid&&(r.AfterSid=e.AfterSid),this._request.get(t,h.x6,r).then((e=>new Ue(e.contents.map((e=>new je(e))),(e=>this._getPage({AfterSid:e})),e.after_sid)))}_insertTaskQueue(e){const t=e.sid;this._log.trace("_insertTaskQueue(sid=%s, data=%s",t,JSON.stringify(e));try{this._TaskQueues.set(t,new xe(e))}catch(e){this._log.error("Unable to create a TaskQueue for sid=%s. Skipping insert into TaskQueue map. Error: %s",t,e)}}}const Ne=class extends Oe{constructor(e,t={}){if(super(e,t),"admin"!==this.role.toLowerCase())throw new TypeError('A token with the "admin" role is required to use this functionality.');this.workspaceEntity=new Pe(this._config,this._request,t)}fetchWorkers(){return this.workspaceEntity.fetchWorkers().then((()=>this.workspaceEntity.Workers))}fetchTaskQueues(){return this.workspaceEntity.fetchTaskQueues().then((()=>this.workspaceEntity.TaskQueues))}}},142:(e,t,r)=>{"use strict";r.d(t,{M0:()=>i,in:()=>s,j3:()=>o,hO:()=>n,O:()=>a,iz:()=>d,nB:()=>c,FB:()=>h,Uf:()=>l,iR:()=>u,UA:()=>p,xf:()=>g,EA:()=>_,qG:()=>k,VH:()=>f,Qh:()=>w,Nt:()=>v,L3:()=>m,zb:()=>S,fc:()=>E,PQ:()=>y,_G:()=>T,l4:()=>b,x6:()=>R,F3:()=>W,L8:()=>q,jz:()=>A,Iv:()=>C,Gf:()=>F});const i="accepted",s="completed",o="rejected",n="wrapping",a="call",d="dequeue",c="redirect",h="conference",l=Object.freeze({canceled:"canceled",complete:"complete",failed:"failed",initiated:"initiated"}),u={activitySid:"WorkerActivitySid"};Object.freeze(u);const p={rejectPendingReservations:"RejectPendingReservations"};Object.freeze(p);const g={accept:"CallAccept",record:"CallRecord",statusCallbackUrl:"CallStatusCallbackUrl",timeout:"CallTimeout",to:"CallTo"};Object.freeze(g);const _={to:"DequeueTo",from:"DequeueFrom",postWorkActivitySid:"DequeuePostWorkActivitySid",record:"DequeueRecord",timeout:"DequeueTimeout",statusCallbackUrl:"DequeueStatusCallbackUrl",statusCallbackEvents:"DequeueStatusCallbackEvents"};Object.freeze(_);const k={accept:"RedirectAccept"};Object.freeze(k);const f={taskChannelUniqueName:"TaskChannelUniqueName",taskChannelSid:"TaskChannelSid",attributes:"Attributes"},w="completed",v="wrapping";Object.freeze({accepted:0,rejected:1,timeout:2,canceled:3,rescinded:4,completed:5,wrapup:6});const m={"task.updated":"updated","task.canceled":"canceled","task.completed":"completed","task.wrapup":"wrapup"};Object.freeze(m);const S={"reservation.completed":"completed","reservation.rejected":"rejected","reservation.timeout":"timeout","reservation.canceled":"canceled","reservation.rescinded":"rescinded","reservation.accepted":"accepted","reservation.wrapup":"wrapup"};Object.freeze(S);const E=Object.freeze({taskTransfer:"task_transfer",activeOutgoingTaskTransfer:"active_outgoing_task_transfer"}),y="transfer-initiated",T={"transfer-attempt-failed":"attemptFailed","transfer-completed":"completed","transfer-failed":"failed","transfer-initiated":"transferInitiated","transfer-canceled":"canceled"};Object.freeze(T);const b={"task.transfer-attempt-failed":"transfer-attempt-failed","task.transfer-completed":"transfer-completed","task.transfer-failed":"transfer-failed","task.transfer-initiated":"transfer-initiated","task.transfer-canceled":"transfer-canceled"};Object.freeze(b);const R="v1",W="v2",q=1e3,A=5e3,C={TOKEN:"token",CLOSE_EXISTING_SESSIONS:"closeExistingSessions",CLIENT_VERSION:"clientVersion"},O=r(830),F=[{name:"INVALID_ARGUMENT",message:"One or more arguments passed were invalid."},{name:"INVALID_TOKEN",message:"The token is invalid or malformed."},{name:"TOKEN_EXPIRED",message:"Worker's active token has expired."},{name:"GATEWAY_CONNECTION_FAILED",message:"Could not connect to Twilio's servers."},{name:"GATEWAY_DISCONNECTED",message:"Connection to Twilio's servers was lost."},{name:"INVALID_GATEWAY_MESSAGE",message:"The JSON message received was malformed."},{name:"TASKROUTER_ERROR",message:"TaskRouter failed to complete the request."}].reduce(((e,t)=>(e[t.name]=new O(t),e)),{})},813:(e,t)=>{function r(e){if(!(this instanceof r))return new r(e);e=e||{};const t=function(){},i={interval:10,now:function(){return(new Date).getTime()},repeat:function(e,t){return setInterval(e,t)},stop:function(e,t){return clearInterval(e,t)},onsleep:t,onwakeup:t};for(let t in i)t in e||(e[t]=i[t]);this.interval=e.interval,this.lastbeat=0,this.pintvl=null,this.onsleep=e.onsleep,this.onwakeup=e.onwakeup,this.repeat=e.repeat,this.stop=e.stop,this.now=e.now}r.toString=function(){return"[Twilio.Heartbeat class]"},r.prototype.toString=function(){return"[Twilio.Heartbeat instance]"},r.prototype.beat=function(){if(this.lastbeat=this.now(),this.sleeping()){this.onwakeup&&this.onwakeup();var e=this;this.pintvl=this.repeat.call(null,(function(){e.check()}),1e3*this.interval)}},r.prototype.check=function(){const e=this.now()-this.lastbeat;!this.sleeping()&&e>=1e3*this.interval&&(this.onsleep&&this.onsleep(),this.stop.call(null,this.pintvl),this.pintvl=null)},r.prototype.sleeping=function(){return null===this.pintvl},t.y=r},442:(e,t,r)=>{"use strict";r.r(t),r.d(t,{default:()=>s});const i=r(142).Gf;class s{constructor(e,t,r){if(!e)throw i.INVALID_ARGUMENT.clone("Error instantiating Paginator. <Array>items is a required parameter.");if(!t)throw i.INVALID_ARGUMENT.clone("Error instantiating Paginator. <Function>source is a required parameter.");this._nextToken=r,this._source=t,this.hasNextPage=!!this._nextToken,this.items=e}nextPage(){return this.hasNextPage?this._source(this._nextToken):Promise.reject(i.TASKROUTER_ERROR.clone("Error getting the next page. No next page exists."))}}},834:(e,t,r)=>{"use strict";function i(e){try{return new Date(e)}catch(e){return null}}function s(e,t){for(const r in e)if(r in t&&!t[r](e[r]))throw new TypeError(`Option key: ${r} does not meet the required type.`);return!0}r.d(t,{T:()=>i,n:()=>s})},830:(e,t,r)=>{function i(e,t){Object.defineProperties(this,{_errorData:{value:e},name:{value:e.name},message:{value:t||e.message}})}(0,r(464).inherits)(i,Error),i.prototype.clone=function(e){return new i(this._errorData,e)},e.exports=i},622:e=>{"use strict";e.exports=require("loglevel")},464:e=>{"use strict";e.exports=require("util")},352:e=>{"use strict";e.exports=require("ws")}},t={};function r(i){var s=t[i];if(void 0!==s)return s.exports;var o=t[i]={exports:{}};return e[i](o,o.exports,r),o.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var i in t)r.o(t,i)&&!r.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var i=r(873);module.exports=i})();